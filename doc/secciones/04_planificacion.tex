\chapter{Planificación}

La planificación es algo esencial para todos los proyectos, y juega un papel aún 
más importante si cabe, cuando se involucra el desarrollo ágil, como es el caso. 

Por tanto, en este capítulo detallaremos que metodologías se van a seguir, como 
se va a organizar temporalmente el proyecto, y como se ha ido siguiendo el 
desarrollo y asegurando la calidad del mismo. 

\section{Metodología utilizada}

A continuación documentaremos que herramientas y métodos se ha ido empleando 
durante el proyecto para ir guiando su desarrollo. Asegurando de esta forma, que 
con el tiempo no se pierda el enfoque y los objetivos iniciales. 

\subsection{Corrector ortográfico}
Para poder asegurar la calidad que buscamos siguiendo los principios del manifiesto
ágil \cite{agile-manifiesto}, no solo del código, sino también del documento
entregable en cuanto a calidad gramatical y ortográfica se refiere, se ha
implementado un corrector que verificará en todo momento que cualquier adición a
la documentación está libre de faltas. 

Para elegir dicho corrector entre todas las posibles alternativas que existen de 
la misma, se ha seguido un proceso de selección en el cual se establecerán 
inicialmente unos criterios de búsqueda con el que encontrar las herramientas. 
Posteriormente, se evaluarán todas las herramientas encontradas usando los 
criterios de selección previamente establecidos.: 

\subsubsection{Criterios de búsqueda}

Los criterios a través de los cuales buscaremos los candidatos para
posteriormente evaluar si cumplen los requisitos de selección:
\begin{itemize}
    \item Deben de incluir el idioma español. No todos los \emph{spell checkers}
    incluyen el idioma español, y si lo incluyen suelen ser de manera muy
    limitada y no tan completa como el idioma base en el que fueron programados.
    \item Deben poderse añadir como \emph{GitHub Action} al repositorio para así
    integrarlos en forma de test, y solamente pase si el texto está correcto.
    \item Debe ser compatible con LaTeX.
\end{itemize}

\subsubsection{Criterios de selección}

Los criterios bajo los cuales evaluaremos los candidatos encontrados en la
búsqueda anterior para finalmente seleccionar uno son:
\begin{itemize}
    \item Debe tener una comunidad activa por si es necesario hacer alguna
    pregunta o consulta en el futuro.
    \item Los informes sobre los fallos existentes deben ser lo más legible y
    fácil de entender posible.
    \item Se valorará que ofrezca posibles correcciones.
    \item Se valorará la posibilidad de excluir palabras del análisis. 

\end{itemize}


\subsubsection{Opciones encontradas según los criterios de búsqueda establecidos}

Tras buscar \emph{spell checkers} que cumplan los requisitos de búsqueda son:

\begin{itemize}
    \item \href{https://github.com/marketplace/actions/textidote-action}{TeXtidote Action}
\end{itemize}

Desafortunadamente, únicamente he podido encontrar un \emph{spell checker} que
cumpliese todos los requisitos de búsqueda previamente establecidos. Ya que otros
encontrados \textbf{no cumplían algunos de los requisitos}:
\begin{itemize}
    \item \href{https://github.com/marketplace/actions/cspell-action}{cspell-action} Pensado principalmente para código no para documentos LaTeX. Nada de español.
    \item \href{https://github.com/marketplace/actions/spell-checker-action}{Spell Checker Action}: Compatible únicamente con inglés. No está centrado en LaTeX. 
    \item \href{https://github.com/valentjn/vscode-ltex}{VSCode LTeX}: No dispone de GitHub Action.
    \item \href{https://github.com/erodner/latex-checks}{LaTeX-Checks}: No dispone de GitHub Action. Solo para inglés y alemán.
\end{itemize}

\subsubsection{Proceso de selección y estudio}
Dado que solo hay un corrector ortográfico a analizar, el proceso de estudio y
decisión entre las alternativas no es estrictamente necesario, pero igualmente
se realizará según los criterios de selección previamente establecidos para ver
en que lugar queda: 

\begin{todolist}
    \item[\xcmark] Debe tener una comunidad activa por si es necesario hacer
    alguna pregunta o consulta en el futuro. Cumple este requisito pues se
    mantiene activo en GitHub resolviendo los issues y PR de la comunidad.
    \item[\xcmark] Los informes sobre los fallos existentes deben ser lo más
    legible y fácil de entender posible. Cumple este requisito pues genera un
    reporte en HTML con los problemas resaltados en colores llamativos.
    \item[\xcmark] Se valorará que ofrezca posibles correcciones. Cumple este
    requisito pues en dicho reporte al poner el cursor encima te sugiere
    revisiones.
    \item[\xcmark] Se valorará la posibilidad de excluir palabras del análisis.
    Cumple el requisito aunque bastante raspado, ya que permite excluir palabras
    mediante un diccionario de palabras excluidas, sin embargo, no permite
    excluir una única aparición puntual de la misma.
\end{todolist}

\subsubsection{Conclusión}
Finalmente, dado que es la única alternativa que se ajusta completamente a los
requisitos de búsqueda y además cumple en mayor o menor medida con los
requisitos de selección establecidos, se ha implementado esta solución como
GitHub Action en el repositorio, para asegurar la calidad del documento
entregable.

\subsection{Test runner: Java y Kotlin}

\subsubsection{Criterios de búsqueda}

Los criterios a través de los cuales buscaremos los candidatos para
posteriormente evaluar si cumplen los requisitos de selección:
\begin{itemize}
    \item Se buscarán test runners que sean compatibles con Java y Kotlin.
    Puesto que vamos a trabajar con dos lenguajes distintos, pero que a su vez
    comparten muchas similitudes y bibliotecas, con el fin de ahorrar en tener
    que invertir tiempo en aprender y comprender dos frameworks de testing
    diferentes, buscaremos uno que se pueda incluir en ambos lenguajes,
    ahorrando de esta manera tiempo y código. 
    \item Se buscará que no estén centrados en BDD, ya que, algunos test runners
    están centrados en dicho enfoque y basan su sintaxis en el \emph{Scenario,
    Given, When y Then}, lo cual se aleja del enfoque DDD empleado en este proyecto.
\end{itemize}

\subsubsection{Criterios de selección}

Los criterios bajo los cuales evaluaremos los candidatos encontrados en la
búsqueda anterior para finalmente seleccionar el que más se adecúe son:
\begin{itemize}
    \item Se valorará el nivel de documentación que tenga así como de los
    ejemplos y tutoriales hechos por la comunidad.
    \item Se tendrá en cuenta la compatibilidad con IDE.
\end{itemize}


\subsubsection{Opciones encontradas según los criterios de búsqueda establecidos}

Tras buscar \emph{test runners} que cumplan los requisitos de búsqueda encontramos:

\begin{itemize}
    \item \href{https://junit.org/junit5/}{JUnit}
    \item \href{https://testng.org/doc/index.html}{TestNG}
\end{itemize}

Otros \emph{test runners} encontrados, pero que no cumplían los requisitos de búsqueda son:
\begin{itemize}
    \item \href{https://spockframework.org/}{Spock}: Centrado en BDD y \href{https://kotlinlang.org/api/latest/kotlin.test/}{no es soportado nativamente por Kotlin}, aunque se puede añadir gracias a Groovy.
    \item \href{https://cucumber.io/}{Cucumber} Centrado en BDD y \href{https://kotlinlang.org/api/latest/kotlin.test/}{no es soportado nativamente por Kotlin}.
    \item \href{https://github.com/karatelabs/karate}{Karate} Centrado en BDD y \href{https://kotlinlang.org/api/latest/kotlin.test/}{no es soportado nativamente por Kotlin}.
\end{itemize}


\subsubsection{Proceso de selección y estudio}

\subsubsection{JUnit}

\begin{todolist}
    \item[\xcmark] Se valorará el nivel de documentación que tenga así como de
    los ejemplos y tutoriales hechos por la comunidad: Cumple encarecidamente
    este requisito, ya que, es el \emph{test runner} por excelencia en Java, por
    tanto, es el más usado y el que más ejemplos, tutoriales y documentación
    posee.
    \item[\xcmark] Se tendrá en cuenta la compatibilidad con IDE: Cumple este
    requisito sin problemas, puesto que, existe
    \href{https://code.visualstudio.com/docs/java/java-testing}{esta extensión para
    Visual Studio Code} que lo hace compatible y además
    \href{https://www.jetbrains.com/help/idea/junit.html}{viene por defecto con
    IntelliJ IDEA}
\end{todolist}


\subsubsection{TestNG}

\begin{todolist}
    \item Se valorará el nivel de documentación que tenga así como de los
    ejemplos y tutoriales hechos por la comunidad: A pesar de que hay bastante
    bibliografía y ejemplos, no está al nivel de JUnit y de hecho incluso la
    página oficial tiene un aspecto más antiguo y descuidado que el de JUnit.
    \item[\xcmark] Se tendrá en cuenta la compatibilidad con IDE: Cumple este
    requisito sin problemas, pues, existe
    \href{https://code.visualstudio.com/docs/java/java-testing}{esta extensión para
    Visual Studio Code} que lo hace compatible y además
    \href{https://www.jetbrains.com/help/idea/testng.html}{viene por defecto con
    IntelliJ IDEA}
\end{todolist}


Por lo que tras valorar mediante los criterios de selección los \emph{test
runners} principales encontrados según los criterios de búsqueda, podemos ver
que el que satisface todos los criterios es \textbf{JUnit}. Por lo que este será
el \emph{test runner} empleado para Java y para Kotlin.


\subsection{Biblioteca de aserciones: Java y Kotlin}

La elección de una biblioteca de aserciones no es excluyente de prescindir de
otras, ya que, puede haber conjuntamente más de una a la vez en un mismo
proyecto. Por lo que se empleará la resulte más conveniente según lo que se esté
testeando. Así pues este proceso de selección no buscará quedarse con una sola
opción, sino consultar las existentes para tenerlas en conocimiento y poder
optar por una o por otra en el momento en el que se necesiten.

\subsubsection{Criterios de búsqueda}

Los criterios a través de los cuales buscaremos los candidatos para
posteriormente evaluar si cumplen los requisitos de selección:
\begin{itemize}
    \item Bibliotecas de aserciones que sean compatibles con JUnit (el
    \emph{test runner} que estamos usando)
\end{itemize}

\subsubsection{Resultados tras la búsqueda}

Las diferentes opciones que se han encontrado compatibles con nuestros criterios
de búsqueda son:

\begin{itemize}
    \item La biblioteca que proporciona JUnit: Básica y con una sintaxis poco
    natural. Pero suficiente para cosas simples o sencillas.
    \item \href{https://github.com/assertj/assertj}{AssertJ}: Mucho más completa
    que la que incorpora JUnit, con sintaxis mucho más natural y con la
    posibilidad de crear tus propias aserciones. Es una de las más empleadas.
    \item \href{http://www.awaitility.org/}{Awaitility}: Se centra en brindar y
    facilitar los test de manera legible para sistemas asíncronos.
    \item \href{https://site.mockito.org/}{Mockito}: Utilizado por excelencia para
    ``mockear'', tiene la ventaja de que se adapta tanto a escenarios simples
    como para escenarios más complejos y avanzados o específicos. Se suele
    añadir en conjunto a AssertJ y es otro de los más frecuentados por la comunidad.
    \item \href{https://github.com/voodoodyne/subethasmtp}{Wiser}: Librería de
    uso exclusivo para ``mockear'' un servidor SMTP. 
    \item \href{https://github.com/marschall/memoryfilesystem}{Memoryfilesystem}
    y \href{https://github.com/google/jimfs}{Jimfs}: Librerías para
    ``mockear'' entrada y salida de memoria. 
    \item \href{https://wiremock.org/docs/overview/}{WireMock}: Librería para
    ``mockear'' servidores HTTP
    \item \href{https://testcontainers.com/}{Testcontainers}: Framework muy
    interesante para ``mockear'' cualquier cosa que pueda ejecutarse en un
    contendor Docker. 
\end{itemize}

Se han añadido librerías para ``mockear'' a pesar de no ser bibliotecas de
aserciones como tal, pero que pueden ser requeridas igualmente según lo que se
esté testeando. Igualmente, existirán más librerías y frameworks específicos para hacer
\emph{mocks} más concretos según necesidad.



\section{Temporización}

\section{Seguimiento del desarrollo}
