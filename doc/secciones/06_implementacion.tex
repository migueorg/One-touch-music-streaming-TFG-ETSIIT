\chapter{Implementación}

La implementación del software se ha dividido en hitos. Estos han sido definidos en GitHub
y cada uno de ellos contiene un grupo de \textit{issues} que se corresponden con las distintas
mejoras que se han ido incorporando al software a lo largo de su desarrollo.\\

\section{Primeros planteamientos para el proyecto}

\subsection{Proyecto como aplicación final}

Los primeros pasos para afrontar este proyecto se hicieron proponiendo crear dos
aplicaciones reproductoras de audio, una para Android y otra para Linux. Ambas
tendrían acceso a una misma biblioteca compartida de archivos MP3, la cual
estaría en red, por lo que ambos reproductores tendrían conocimiento y acceso a
la misma colección de audio. En dicha biblioteca todos los elementos estaría
asociados a un identificador, por lo que cuando el móvil y el altavoz se
comunicasen a través del NFC, se transferiría el identificador del archivo de la
reproducción actual, además del segundo actual. De esta forma el altavoz sabría
que elemento de la biblioteca reproducir y en que segundo comenzar.

El problema de esta solución era que la biblioteca dependía del usuario final,
por lo que conllevaba andar añadiendo canciones y podcast manualmente, como si
de 2008 se tratase... Por tanto, generaba más problemas de los que solucionaba,
por lo que se decidió darle al proyecto un enfoque como servicio en lugar una
aplicación para un usuario final.

De esta manera, el proyecto como servicio sería integrado por otras aplicaciones
de reproducción, dejando el tema de proveer el contenido a cargo de las mismas.

\subsection{Proyecto como servicio - Google Cast}

Al enfocarlo como servicio se propuso emplear algún protocolo amplio y conocido
como es \emph{Google Cast} \cite{google-cast}, de modo que el receptor de audio
fuese un servidor de \emph{Google Cast}, y el servicio en \emph{Android}
estuviese a la espera de una interacción NFC para conectarse mediante
\emph{Cast} al servidor con el que se hubiese comunicado. 

El problema que hubo con este planteamiento y por lo que también se descartó es
que Google no permite que dispositivos ``no genuinos'' sean usados como
servidores de \emph{Google Cast}. Esto significa que únicamente se permite dotar
de servidor \emph{Cast} a los dispositivos licenciados por \emph{Google} como
pueden ser los \emph{Google Chromecast, Google Home, Google Nest, etc}. Por lo
que hubo que desechar ese protocolo de transmisión y buscar otra alternativa
libre.

\subsection{Proyecto como servicio - HLS/WebRTC/RTSP}

Al desechar el uso de \emph{Google Cast} hubo que bajar un nivel de abstracción
para buscar alternativas libres y desarrollar un \emph{Google Cast} propio que
permitiese enviar el audio a un servidor. Tras el estudio de las \emph{API} de
\emph{Android} se optó por emplear la \emph{API} existente en \emph{Android 10
(SDK29)} llamada \emph{AudioPlaybackCapture} \cite{api-audio-capture}, la cual
permite capturar el audio interno de \emph{Android}, para posteriormente
procesarlo, grabarlo, o trabajar libremente con él. Por lo que el nuevo enfoque
sería enviarlo a través de cualquier protocolo de streaming como puede ser \emph{HLS,
WebRTC o RTSP} tras capturarlo con la mencionada \emph{API}.


\section{Selección del lenguaje de programación}

Dentro del proyecto se ven involucrados más de un dispositivo, ya que coexisten
dispositivo móvil y receptor. Ambos podrían llegar a programarse usando el mismo
lenguaje, lo cual sería ventajoso, puesto que, se unificaría el \emph{toolchain} e
incluso se podría ahorrar código. Pero dado que existen requisitos o
dependencias más prioritarias (las cuales serán detalladas en los requisitos de
búsqueda y selección), la elección se dejará a juicio del proceso de selección.

\subsection{Dispositivo móvil}

En este aspecto no tenemos mucho donde elegir. Si hablamos de dispositivos
móviles estamos hablando de \emph{Android} e \emph{iOS}. Y puesto que ya
descartamos \emph{iOS} en la introducción del problema, por ser un sistema
operativo más cerrado y buscar centrarnos en un sistema operativo abierto, el
sistema operativo móvil sobre el que se centrará el proyecto será \emph{Android}.

Si queremos programar en \emph{Android} primero debemos decidir si queremos hacer una
aplicación nativa, híbrida o generada \cite{nativo-hibrido-generado}. Las
aplicaciones nativas se programan en lenguajes con soporte nativo por el sistema
operativo, por lo que tienen un aspecto más similar al propio sistema operativo,
y un mejor rendimiento, sin embargo, requieren de más esfuerzo de desarrollo. Las
aplicaciones híbridas son aplicaciones web que se ejecutan en un navegador web
simulando ser una aplicación nativa, por lo que la interfaz no suele tener un
aspecto tan uniforme al sistema y el rendimiento suele ser notablemente
inferior. Y las generadas son aplicaciones que se programan en un lenguaje no
nativo, pero que mediante un \emph{framework} son traducidas a lenguajes nativos, sin
embargo, al depender de traducción el rendimiento no llega a ser el mismo que el
de una aplicación nativa.

A la hora de elegir qué usar para este proyecto entre los tres tipos de
aplicaciones mencionados, la interfaz gráfica no es algo a tener en cuenta, ya
que, no vamos a hacer una aplicación como tal, sino un servicio para que otras
aplicaciones implementen. Sin embargo, sí que tenemos que tener en cuenta el
rendimiento así como el acceso y manejo con el sistema operativo o con
componentes hardware de más bajo nivel, como es el \emph{NFC}. Para estos casos las
aplicaciones nativas son una mejor elección, ya que, al existir menos capas entre
la aplicación y el sistema operativo, obtienen un mejor rendimiento, y facilitan
la comunicación con componentes hardware de bajo nivel. Lo cual nos lleva a
optar por una aplicación nativa.

Para programar una aplicación nativa existen varios lenguajes que lo permiten
\cite{lenguajes-nativos}, sin embargo, dado que vamos a requerir de comunicación
con elementos hardware como es el lector \emph{NFC}, vamos a optar por lenguajes
que tengan una documentación extensa y detallada en cuanto a desarrollo móvil y
comunicación con \emph{Android}, reduciendo estos lenguajes nativos a \emph{Java} y
\emph{Kotlin}, puesto que, son para los que existe más bibliografía y ejemplos
relacionados con este sistema operativo móvil.

Finalmente, para optar por uno u otro, \emph{Google} lo tiene claro, ya que desde 2019
están enfocados en \emph{Kotlin} y buscan que sea el principal lenguaje de \emph{Android}
\cite{prioridad-kotlin}. De hecho como ellos mismos explicaron, desde 2019 cada
vez que desarrollan una \emph{API} o contenido nuevo lo hacen teniendo en mente
el uso con \emph{Kotlin}, por lo que este lenguaje será el más indicado si lo que
pretendemos es usar alguna \emph{API} que se comunique con el \emph{NFC} del
sistema \emph{Android}.

Así que, teniendo todo esto en cuenta, el lenguaje utilizado para el
dispositivo móvil será \textbf{\emph{Kotlin}}

\subsection{Dispositivo receptor: módulo NFC}

Este dispositivo utilizará \emph{Linux}, ya que es el sistema operativo que está
presente en casi la totalidad de placas de desarrollo y mini PC que lo cual
facilitará enormemente el desarrollo. 

\subsubsection{Criterios de búsqueda}

Dado que correr \emph{Linux} no es algo limitante a la hora de elegir lenguaje de
programación, el principal factor que fijará el criterio de búsqueda es la
compatibilidad con librerías NFC actualizadas.

\begin{itemize}
    \item Debe de ser compatible con librerías NFC.
    \item Debe ser un lenguaje tocado previamente en alguno de los años del grado.
\end{itemize}

\subsubsection{Criterios de selección}

Las propuestas encontradas bajo los criterios de búsqueda serán evaluadas bajo
los siguientes criterios de selección:

\begin{itemize}
    \item La librería debe estar mantenida o recibir actualizaciones cada poco tiempo.
    \item Debe de tener documentación extensa en la que se valorarán los ejemplos ya hechos.
    \item La instalación de la misma debe de ser lo más simple posible.
    \item Se valorará muy positivamente la facilidad o simplicidad del lenguaje a la hora de manejar los datos a enviar o recibir con el NFC.
\end{itemize}

\subsubsection{Opciones encontradas según los criterios de búsqueda establecidos}

\begin{itemize}
    \item Java: \href{https://github.com/grundid/nfctools}{nfctools}. Si bien al
    hablar de Java esperaba que existiese una gran cantidad de librerías, no han
    sido tantas las encontradas. Siendo la mayoría librerías comerciales para
    lectores NFC concretos.
    \item Python: \href{https://github.com/nfcpy/nfcpy}{nfcpy}. Al igual que con
    Java, la búsqueda ha devuelto menos librerías de las esperadas. Aunque en
    este caso casi todas las entradas y proyectos existentes con NFC en Python
    apuntaban a esta librería.
    \item C: \href{https://github.com/nfc-tools/libnfc}{libnfc}. 
    \item C++: \href{https://github.com/liblogicalaccess/liblogicalaccess}{LibLogicalAccess}.
\end{itemize}

\subsubsection{Proceso de selección y estudio}

\subsubsection{Java: nfctools}

\begin{todolist}
    \item El repositorio de \href{https://github.com/grundid/nfctools}{GitHub}
    no ha recibido actualización desde 2014. Si bien algún colaborador ha
    seguido trabajando en su propia rama del proyecto algún tiempo, los cambios
    ni siquiera han sido fusionados con \emph{master} e incluso esa rama más
    actualizada lleva 3 años sin un \emph{commit}. Por lo que este requisito no lo
    cumple dicha librería, y, por tanto, tampoco Java.
    \item Esta librería no tiene documentación más que el
    \href{https://github.com/grundid/nfctools/blob/master/README}{README de
    GitHub} y la \href{https://www.grundid.de/nfc/index.html}{web del proyecto},
    la cual hace más de portal inicial que de documentación. Por lo que no
    cumple este requisito.
    \item Al no tener documentación hace que el proceso de instalación requiera
    de intentos a ciegas, investigación y avances según prueba y error. Por lo
    que no cumple este requisito.
    \item[\xcmark] Java es un lenguaje con el que se puede trabajar y manejar
    los datos de forma medianamente fácil, ya que dispone de clases hechas que
    automatizan y facilitan parte del proceso. Aunque igualmente si se compara
    con otros lenguajes habrá alternativas que simplifiquen aún más el proceso.
    Sin embargo, considero este requisito como válido.
\end{todolist}

\subsubsection{Python: nfcpy}

\begin{todolist}
    \item [\xcmark] El último \emph{commit} en el repositorio de
    \href{https://github.com/nfcpy/nfcpy}{GitHub} fue en marzo de 2022 cuando
    lanzó el último \emph{release}. Mientras que la última actividad del principal
    contribuidor de la organización que lleva el repositorio fue a finales de
    agosto contestando issues; por lo que podemos decir que aunque no de manera
    continuada o diaria, la librería sigue recibiendo soporte y está activa, por
    lo que cumple este requisito.
    \item [\xcmark] Posee
    \href{https://nfcpy.readthedocs.io/en/latest/index.html}{readthedocs} en
    donde se detallan los primeros pasos, instalación, ejemplos, etc. Es
    bastante completa y concisa por lo que también satisface con creces este
    requisito.
    \item [\xcmark] Para instalarlo basta con emplear pip, ya que está publicado en
    \href{https://pypi.org/project/nfcpy/}{PyPi}. Por lo que se instala de una
    forma rápida y sencilla.
    \item[\xcmark] Python es uno de los lenguajes más simples y sencillos de
    usar, especialmente como se está viendo últimamente para el manejo de datos,
    por lo que este requisito lo cumple de manera sobrada.
\end{todolist}

\subsubsection{C: libnfc}

\begin{todolist}
    \item [\xcmark] El último \emph{commit} del repositorio de
    \href{https://github.com/nfc-tools/libnfc}{GitHub} fue en febrero de 2023,
    por lo que podríamos decir que si mantiene el soporte, sin embargo,
    revisando los \emph{issues} y los \emph{pull request} están en su mayoría
    desatendidos desde hace años. Y de hecho los \emph{commits} de los últimos años son
    simplemente de fusionar algunos PR aceptados, por lo que da la sensación que
    el soporte que recibe es el de comprobar cada ciertos meses los \emph{pull
    request} activos y aprobarlos si son cambios que no requieren mucha
    intervención. Sin embargo, aún sabiendo esto, interpretaré como que recibe
    soporte, ya que en cierto modo es así.
    \item Posee cierta documentación muy básica en el README del repositorio, y
    adicionalmente tienen \href{nfc-tools.org}{una web} en la que se supone que
    tienen una comunidad, una wiki detallada, etc. Pero esta web no responde en
    el momento de hacer el estudio, por lo que se entiende que la web ha sido
    abandonada, por tanto, no cumple este requisito.
    \item Para instalar la librería primero hay que clonar el repositorio,
    ejecutar el \emph{script} de configuración y una vez generados los archivos
    de configuración, compilar con \emph{make}, para después finalmente ejecutar otro
    \emph{make install}. Una vez completado el \emph{makefile} hay que copiar los binarios
    resultantes a cierta ruta y configurar el \emph{path}. Aunque son unos pasos
    no muy complicados que cualquier estudiante del grado podría superar, no es
    un proceso rápido o sencillo si lo comparamos con el de la librería de
    Python la cual se instalaba automáticamente con pip. Por tanto, considero que
    no supera este requisito.
    \item C no es un lenguaje especialmente simple a la hora de tratar con
    datos, pues no dispone de una STL como es el caso de C++ en el que se
    simplifique el trabajo con vectores etc. Habría que hacerlo manualmente con
    malloc, calloc, free, etc. Por lo que se aleja mucho de la simplicidad o
    facilidad para el manejo. Debido a esto, no supera el requisito.
\end{todolist}

\subsubsection{C++: LibLogicalAccess}

\begin{todolist}
    \item [\xcmark] El último \emph{commit} del repositorio de
    \href{https://github.com/liblogicalaccess/liblogicalaccess}{GitHub} fue en
    marzo de 2023, y los \emph{issues} y \emph{pull request} se mantienen todos
    atendidos, por lo que denota que se mantiene activo y con soporte del
    desarrollador. Por tanto, cumple este requisito.
    \item [\xcmark] Utiliza la wiki de GitHub a modo de documentación, teniendo
    documentado el proceso de instalación y algunos ejemplos en hardware
    concreto. Además, posee una \href{https://liblogicalaccess.com/}{web oficial}
    en la que tienen publicado el Doxygen. Podemos decir que cumple dicho requisito,
    aunque comparando con algunas otras alternativas vistas, no es la más
    completa.
    \item Para instalar la librería hay que utilizar un software llamado
    \href{https://conan.io/}{conan}, el cual es un gestor de paquetes para C y
    C++ tras clonar y compilar el repositorio con conan. Adicionalmente, este
    software se instala a través de pip, por lo que habría que instalar también
    pip, ya que con una instalación de gcc no se instala. Por tanto, no considero
    que sea una instalación necesariamente simple, por lo que no cumple este
    requisito.
    \item [\xcmark] A pesar de que C++ tiene la STL la cual simplifica mucho el manejo de
    datos con las clases ya hechas y la automatización de la memoria dinámica
    que se hace dentro de la misma, el manejo de datos no es la tarea más simple
    dentro de C++. Sin embargo, aunque sea por los pelos o ``cogido con pinzas'',
    daré como cumplido este requisito.
\end{todolist}

\subsubsection{Conclusión}

Tras valorar mediante los criterios de selección los lenguajes principales
encontrados según los criterios de búsqueda, podemos ver que el lenguaje que
satisface todos los criterios es \textbf{Python con la librería nfcpy}. Por lo que este
será el lenguaje empleado para el módulo NFC en la parte del receptor.

\subsection{Dispositivo receptor: módulo audio streaming}

Este dispositivo es el mismo que el que ejecutará el módulo de NFC, sin embargo,
para reproducir el audio en streaming se tendrán unos requisitos diferentes que
para el estudio anterior, por lo que será necesario un proceso de selección
nuevo con los nuevos criterios.

\subsubsection{Criterios de búsqueda}

Para capturar y enviar el audio desde la parte de Android se emplean bibliotecas
de Java. Por lo que el lenguaje que se emplee para el audio en streaming debería
ser compatible con esas bibliotecas, ya que de esta forma se reduciría bastante
el tiempo de programación pues con los conceptos y funciones aprendidos para la
parte del dispositivo Android, cubriríamos también los del receptor. A su vez al
utilizar las mismas bibliotecas se reducirían los posibles errores o
incompatibilidades. Por lo que los criterios de búsqueda serán:

\begin{itemize}
    \item Debe de tener compatibilidad nativa con las mismas librerías empleadas
    en la parte del dispositivo Android.
    \item No se tendrán en cuenta las variantes de otros lenguajes de
    programación que traducen en tiempo real el código a Java (Jython, JGo,
    JRuby, etc.)
\end{itemize}

\subsubsection{Criterios de selección}

Las propuestas encontradas bajo los criterios de búsqueda serán evaluadas bajo
los siguientes criterios de selección:

\begin{itemize}
    \item La instalación del lenguaje en modo \emph{headless} debe ser lo más simple posible.
    \item La ejecución de código debe de ser lo más simple posible.
    \item Se valorará positivamente el haberse estudiado en algún momento a lo largo del grado.
\end{itemize}

\subsubsection{Opciones encontradas según los criterios de búsqueda establecidos}

\begin{itemize}
    \item \href{https://www.java.com/es/}{Java}.
    \item \href{https://kotlinlang.org/}{Kotlin}.
    \item \href{https://groovy-lang.org/}{Groovy}
    \item \href{https://www.scala-lang.org/}{Scala}
\end{itemize}

Ambos lenguajes soportan nativamente las bibliotecas de Java, ya que Kotlin tiene
compatibilidad nativa con Java al ejecutarse también en una JVM.

\subsubsection{Proceso de selección y estudio}

\subsubsection{Java}

\begin{todolist}
    \item[\xcmark] Java es un lenguaje muy extendido y conocido, así como
    antiguo, por lo que al llevar tanto tiempo usándose y por
    \href{https://www.stackscale.com/es/blog/lenguajes-programacion-mas-populares/}{una
    cantidad tan grande de usuarios} ha hecho que esté disponible para su
    descarga e instalación en casi la totalidad de repositorios de cada
    distribución (apt, yum, etc.). Por lo que el proceso de descarga, instalación
    y configuración del path queda simplificado a un simple ``apt install
    default-jre'' en el cual incluso se puede especificar fácilmente si se
    necesita alguna versión en particular. Satisfaciendo de forma sobrada este
    requisito.
    \item[\xcmark] Para la ejecución de código en Java gracias a la JVM basta
    con ejecutar el comando ``java'' seguido del archivo con el código, sin
    necesidad de añadir flags ni generar binarios para su posterior ejecución
    manual. Por lo que cumple este requisito.
    \item[\xcmark] Java es un lenguaje bastante utilizado a lo largo del grado,
    en asignaturas como PDOO (Programación y Diseño Orientado a Objetos), FR
    (Fundamentos de Redes)y SM (Sistemas Multimedia); por lo que la curva
    inicial de aprendizaje ya ha sido sobrepasada y no es un lenguaje en el que
    se tenga que empezar de 0.
\end{todolist}

\subsubsection{Kotlin}

\begin{todolist}
    \item Para instalar Kotlin, dado que es un lenguaje mucho más moderno que
    Java, aún no ha sido añadido a los repositorios que vienen por defecto en
    las distribuciones Linux. Por lo que para instalarlo habrá que descargar los
    binarios pre compilados accesibles oficialmente desde GitHub según la
    versión específica a emplear o instalarlo desde un repositorio de terceros
    llamado \emph{SDKMAN} el cual si trae el paquete de Kotlin en su catálogo, y
    permite especificar la versión deseada, pero que para usarlo es necesario
    instalarlo previamente también. Por lo que si bien estos pasos no son
    complicados, al ponerlo en comparación con Java, este queda en peor lugar,
    por lo que no cumple este requisito.
    \item A pesar de que al igual que Java, utiliza la JVM para funcionar, a la hora
    de compilar y ejecutar código
    \href{https://stackoverflow.com/a/69030563}{vemos} que el proceso puede
    variar dependiendo de si es código nativo de Kotlin o si no lo es. Por lo
    que hay que tener en cuenta si añadir el \emph{runtime} para que se pueda ejecutar
    o no, entre otros flags, para generar el ejecutable que posteriormente
    podemos ejecutar. Por lo que al igual que en el requisito de antes, aunque
    no es un proceso complicado y que de hecho está bastante simplificado, si lo
    comparamos con el otro lenguaje analizado, el proceso de Java sigue teniendo
    un proceso más simple para ejecutar el código. Por lo que Kotlin tampoco
    cumple este requisito. 
    \item Kotlin se estudia durante el grado en la asignatura PDM (Programación
    de Dispositivos Móviles), sin embargo, esta asignatura es una optativa de
    cuarto año, y en mi caso no la cursé, por lo que no es un lenguaje que haya
    utilizado previamente en el grado.
\end{todolist}

\subsubsection{Groovy}

\begin{todolist}
    \item Al igual que en Kotlin, para instalar Groovy hay que hacerlo
    descargando desde su web el binario de la versión específica que deseamos
    usar y configurar el path manualmente, o hacerlo también igual que para
    Kotlin, a través de \emph{SDKMAN} especificando la versión concreta a
    instalar si es necesario. Por lo que a pesar de ser un método no muy
    complejo, sigue siendo más laborioso que el de Java.
    \item[\xcmark] Una vez instalado, para ejecutar código en Groovy es tan
    simple como ejecutar el comando ``groovy'' seguido del archivo con el
    código. Por lo que al igual que Java, cumple este requisito.
    \item Groovy no se ha estudiado en ninguna asignatura durante la carrera, al
    menos no en ninguna de las troncales, ni de las optativas que yo haya
    cursado, por lo que no cumple este requisito.
\end{todolist}

\subsubsection{Scala}

\begin{todolist}
    \item Scala se puede instalar descargando el binario manualmente, o a través
    de \emph{Coursier}, el cual es un gestor de dependencias, aplicaciones y
    paquetes para Scala, con la capacidad de preparar el entorno de
    Scala e instalarlo. Además, \emph{Coursier} permite especificar el \emph{tag} de la
    versión a instalar. Sin embargo, \emph{Coursier} también necesita ser
    instalado manualmente por lo que de nuevo, al comparar con el proceso de
    instalación de Java, este es un poco más laborioso.
    \item Para ejecutar código de Scala normalmente hay que crear y construir
    los proyectos con \href{https://www.scala-sbt.org/}{sbt} el cual es una
    herramienta de construcción de proyectos para Scala. Por lo que no cumple
    este requisito al tener que estar construyendo proyectos para ejecutarse.
    (Para códigos simples se puede usar el comando ``scala'' seguido del
    archivo, pero no es una práctica recomendada si se usan librerías, como es
    el caso)
    \item Al igual que Groovy, Scala no ha sido usado previamente en la carrera.
\end{todolist}


\subsubsection{Conclusión}

Tras valorar mediante los criterios de selección los lenguajes principales
encontrados según los criterios de búsqueda, podemos ver que el lenguaje que
satisface todos los criterios es \textbf{Java}. Por lo que este será el lenguaje
empleado para el módulo de audio en streaming en la parte del receptor.


\section{Capturando el audio: Milestone 2}

Para capturar el audio interno como comenté antes, he utilizado la \emph{API
AudioPlaybackCapture} \cite{api-audio-capture} que proporciona \emph{Android} a
partir de \emph{Android 10 (SDK29)}, la cual permite crear un objeto
\emph{AudioRecord} \cite{clase-audiorecord} con la captura del audio del
dispositivo, especificándole la velocidad de muestreo del audio y canales a
partir de la cual podremos trabajar. El inconveniente (y a la vez ventaja según
se mire) de \emph{AudioRecord} es que trabaja a muy bajo nivel, y a diferencia
de otras alternativas como \emph{MediaPlayer} \cite{clase-mediaplayer} que son
soluciones de más alto nivel, habrá que programar manualmente métodos como por
ejemplo el de grabar el audio a un fichero, cosa que \emph{MediaPlayer} si hace
sin tener que incluir nada extra. Sin embargo, al trabajar con bajo nivel
obtendremos un mejor rendimiento. 

Los requisitos de esta \emph{API} son que la
aplicación tenga permisos para acceder al micrófono \footnote{Por la forma en la
que está diseñado Android internamente, se agrupan bajo el mismo permiso de
\emph{RECORD\_AUDIO} el acceso al micrófono y el acceso al audio interno, por lo
que aunque parezca que esta aplicación está solicitando permisos para acceder al
micrófono del dispositivo, no se tiene por qué hacer uso de él.} y a la
proyección de la pantalla.

\newpage

\emph{AudioRecord} al trabajar a bajo nivel, obtiene el audio en
\href{https://en.wikipedia.org/wiki/Raw_audio_format}{\emph{RAW}}, por lo que no
tendrá compresión ni tendrá cabeceras para ser identificado por reproductores;
lo cual significa que a la hora de guardarlo será un fichero con extensión
\emph{RAW} o \emph{PCM} \cite{audio-pcm}.

\begin{figure}[htb]
    \centering
    \includegraphics{fotos/archivo_generado.png}
    \caption{Archivo generado.}
\end{figure}


Por lo que a la hora de reproducirlo habrá que especificar manualmente la
velocidad de muestreo o \emph{samplerate}, profundidad de bits y los canales de
audio que tiene la pista \cite{audio-samplerate}, los cuales normalmente vienen
incrustados en las cabeceras de los formatos de audio procesado.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{fotos/importando_datos_en_bruto_audacity.png}
    \caption{Especificando la composición del audio.}
\end{figure}

Sin embargo, puesto que dichos ficheros con extensión pcm no serán empleados para
el uso final, sino que serán utilizados únicamente durante el desarrollo
para verificar que se está capturando el audio y que satisface el PMV (producto
mínimamente viable); esto no es un inconveniente que haya que tener en
consideración más allá que en el de especificar los datos de codificación a la
hora de abrir el archivo generado. Por tanto, una vez generado el fichero con
extensión \emph{pcm} con la captura del audio, lo reproduciré para comprobar si
se satisface el PMV. 

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{fotos/muestra_captura_audacity.png}
    \caption{Muestra del audio correctamente capturado.}
\end{figure}

Finalmente, si usamos un software compatible con audio en \emph{RAW} como es
\emph{Audacity} \cite{software-audacity}, vemos que el audio ha sido capturado
correctamente y que es reproducible, por lo que, podemos dar como listo el
milestone 2 al tener satisfecho el PMV asignado al mismo. 

\section{Desplegando el receptor de audio: Milestone 3}

Como ya mencioné al inicio de la implementación, el receptor de audio sería un
dispositivo que corra \emph{Linux} ya que esto abriría muchas posibilidades en
cuanto a lenguajes y librerías a usar; por lo que realmente la elección de un
hardware u otro es indiferente mientras ejecute \emph{Linux} y tenga algún
módulo NFC conectado, por ello es que no se ha necesitado un proceso de
selección para este apartado.

En mi caso emplearé una \emph{Raspberry Pi 1b} debido al bajo coste de la misma, su
extensa comunidad y sus puertos de entrada y salida de propósito general
\emph{(GPIO)} [REFERENCIAR AQUÍ LOS GPIO] los cuales de cara al desarrollo abren
las puertas a muchos protocolos de manera fácil y rápida. 

% Insertar foto de la raspberry pi 1b

En cuanto al módulo NFC opté por un PN532 [REFERENCIAR AQUI AL PN532], el cual
tiene un bajo coste y su vez admite varios protocolos de conexión diferentes con
la Raspberry.

% Insertar foto del módulo

Hacer funcionar un chip PN532 en una Raspbery Pi o Arduino es una tarea
sencilla y trivial, sin embargo, durante el desarrollo, tras instalar todo lo
necesario, configurar los drivers y conectar ambos dispositivos; la Raspberry
seguía sin detectar el módulo, independientemente del protocolo de conexión
usado. Por lo que sustituí la Raspberry Pi 1b que estaba empleando por otra
Raspberry Pi 2 

% Insertar foto de la raspberry pi 2

Pero el resultado seguía siendo el mismo incluso después de reinstalar el
sistema y reinstalar los drivers desde cero en la nueva Raspberry. Por lo que
sustituí el módulo PN532 por otro de un fabricante difernte, en este caso uno de
\href{https://www.waveshare.com/wiki/PN532_NFC_HAT}{Waveshare}

% Insertar foto del HAT PN532 de Waveshare

El cual finalmente si que funcionó por lo que saqué como conlusión que el primer
módulo PN532 llegó roto. Lo cual provocó una semana de trabajo perdido entre
pruebas, intentos y tiempos de espera.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{fotos/nfc_poll.jpeg}
    \caption{nfc-poll detectando el PN532 via UART en la Raspberry}
\end{figure}

Para conectar un módulo PN532 a una Raspberry, como mencioné antes, existen
varios protocolos disponibles, los cuales son \emph{UART}, \emph{I2C} y
\emph{SPI}. Sin embargo, tras hacer un estudio de los protocolos compatibles con
la librería \emph{NFC} seleccionada tras un proceso de selección al inicio,
comprobé que el único protocolo compatible con la misma era el de \emph{UART}
(conexión serie), por lo que tampoco fue necesario realizar un proceso de
selección sobre los protocolos disponibles.\\

Una vez operativa la Raspberry y el módulo \emph{NFC}, instalé los lenguajes
elegidos en los procesos de selección que se llevaron a cabo, así como la
librería \emph{NFC (NfcPy)} seleccionada, los cuales no presentaron ningún
problema. Por lo que tras esto, el despliegue y configuración del dispositivo
receptor ya se encontraba listo.